'use strict';

const TranslationUnit = require( './TranslationUnit.js' ),
	MWTemplate = require( './MWTemplate' ),
	languageData = require( '@wikimedia/language-data' ),
	CommonsFilePathPrefix = '//upload.wikimedia.org/wikipedia/commons/';

/**
 * This class is an adapter for block images(<figure>) and inline images(<span>).
 * a) It changes the `File` namespace prefix for resources to corresponding namespace
 *    in target URL, if the resource is refering the file from Wikimedia commons.
 * b) It flips the mw-halign-left or mw-halign-right classes depending language directionality
 *    of source and target language
 * c) If the image is a link, the namespace in the link URL will be adapted for target language.
 *
 * The node will get a new attribute data-cx with adapted key as true or false
 * depending on whether the namespace change happened or not.
 */
class MWImage extends TranslationUnit {
	isInlineMediaWithCaption() {
		// Figure can also mean Video or Audio too. https://www.mediawiki.org/wiki/Specs/HTML/2.4.0#Audio/Video
		return this.node.name === 'span' && this.node.attributes.typeof &&
			this.node.attributes.typeof.match( /(^|\s)(mw:File|mw:Image)\b/ ) &&
			this.node.attributes[ 'data-mw' ] &&
			JSON.parse( this.node.attributes[ 'data-mw' ] ).caption;
	}

	/**
	 * Check if an image is coming from Commons or not. Uses the URL pattern of the common file
	 * repository to determine whether the image is stored there.
	 *
	 * @param {string} imageSrc
	 * @return {boolean}
	 */
	isCommonsResource( imageSrc ) {
		return imageSrc.includes( CommonsFilePathPrefix );
	}

	/**
	 * Adapt the image's alignment settings for the target language.
	 */
	adaptImageAlignment() {

		const sourceDirection = languageData.getDir( this.sourceLanguage );
		const targetDirection = languageData.getDir( this.targetLanguage );

		if ( sourceDirection === targetDirection ) {
			// Source and target languages has same directionality. Nothing to do
			return;
		}

		if ( !this.node.attributes.class ) {
			return;
		}

		const classes = this.node.attributes.class.split( ' ' );
		// If the image has an explicit alignment class in HTML, this means that it has explicit
		// alignment defined in wiki syntax. It must be explicitly flipped if the target language's
		// direction is different.
		const leftIndex = classes.indexOf( 'mw-halign-left' );
		const rightIndex = classes.indexOf( 'mw-halign-right' );
		if ( leftIndex > -1 ) {
			classes[ leftIndex ] = 'mw-halign-right';
		} else if ( rightIndex > -1 ) {
			classes[ rightIndex ] = 'mw-halign-left';
		}

		this.node.attributes.class = classes.join( ' ' );
	}

	async adapt() {
		let imageLink, sourceImage;

		if ( this.node.attributes.typeof.includes( 'mw:Transclusion' ) ) {
			// Node has typeof="mw:Transclusion mw:File"
			// The image is generated by a template. So template adaptation will take care of it.
			// Bug: T298592
			const adapter = new MWTemplate(
				this.node, this.sourceLanguage, this.targetLanguage, this.api, this.context
			);
			return adapter.adapt();
		}
		const dataCX = { adapted: false };

		if ( this.isInlineMediaWithCaption() ) {
			// The image caption is in data-mw attribute.
			if ( this.context.conf.mtClient ) {
				// This is an inline image, Adapting the caption alone.
				const caption = JSON.parse( this.node.attributes[ 'data-mw' ] ).caption;
				const translatedCaption = await this.context.conf.mtClient.translate(
					this.sourceLanguage, this.targetLanguage, caption
				);
				this.node.attributes[ 'data-mw' ] = JSON.stringify( { caption: translatedCaption } );
			}
			dataCX.adapted = true;
			this.node.attributes[ 'data-cx' ] = JSON.stringify( dataCX );
			return this.node;
		}

		// The image is a block media or inline media without a caption.

		this.adaptImageAlignment();

		if ( this.node.children ) {
			const textChunks = this.node.children.textChunks;
			for ( let i = 0, len = textChunks.length; i < len; i++ ) {
				const chunk = this.node.children.textChunks[ i ];
				if ( chunk.tags[ 0 ] && chunk.tags[ 0 ].name === 'a' ) {
					imageLink = chunk.tags[ 0 ];
				}
				if ( chunk.inlineContent && chunk.inlineContent.name === 'img' ) {
					sourceImage = chunk.inlineContent;
					break;
				}
			}
		}

		if ( !sourceImage ) {
			// This node is not a figure or span containing <img>. Could be audio or video
			return this.node;
		}

		if ( sourceImage && this.isCommonsResource( sourceImage.attributes.src ) ) {
			const namespaceAlias = await this.api.getNamespaceAlias( 'File', this.targetLanguage );
			const targetResource = sourceImage.attributes.resource.replace( /^(\.\.?\/)*([^:]+)(:)/, '$1' + namespaceAlias + '$3' );

			// Image does not have a link when it is created with "link=".
			if ( imageLink && imageLink.attributes.href ) {
				imageLink.attributes.href = targetResource;
			}
			dataCX.adapted = true;
		}

		this.node.attributes[ 'data-cx' ] = JSON.stringify( dataCX );
		return this.node;
	}
}

MWImage.matchTagNames = [
	'figure',
	'span'
];

MWImage.matchRdfaTypes = [
	// mw:File(/.*)? will match figure or span containing images, video, and audio.
	// But in the adapt method we process only images. The <img>, <video> and <audio>
	// will be adapted by MWFile adapter module.
	'mw:File', 'mw:File/Thumb', 'mw:File/Frame', 'mw:File/Frameless',
	// TODO: Remove 'mw:Image(/.*)?' when version 2.4.0 of the content is no
	// longer supported
	'mw:Image', 'mw:Image/Thumb', 'mw:Image/Frame', 'mw:Image/Frameless'
];

module.exports = MWImage;
